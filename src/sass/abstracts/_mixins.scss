// =============================================================================
// Mixins | v1.0.0
// -----------------------------------------------------------------------------
// Defines reusable SCSS mixins for the coastalskin theme
//
// This file contains logic-based helpers for generating consistent styles,
// such as media queries, typography styles, button styles, and other commonly
// used patterns. Mixins promote DRY principles and improve maintainability
// across the codebase.
// =============================================================================

// =============================================================================
// Links | v1.0.0
// -----------------------------------------------------------------------------
// Defines interaction state mixins for links and interactive elements in the
// coastalskin theme.
//
// These mixins include utility mixins for common pseudo-class states such as
// `:hover`, `:focus`, `:focus-within`, and their combinations. These mixins
// streamline the application of consistent state-based styles across
// components and reduce style duplication.

@mixin hover {
    &:hover {
        @content;
    }
}

@mixin focus {
    &:focus {
        @content;
    }
}

@mixin focus-within {
    &:focus-within {
        @content;
    }
}

@mixin hover-focus {
    &:hover,
    &:focus {
        @content;
    }
}

@mixin hover-focus-within {
    &:hover,
    &:focus-within {
        @content;
    }
}

// =============================================================================
// Outline | v1.0.0
// -----------------------------------------------------------------------------
// Provides a shorthand outline utility mixin for the coastalskin theme
//
// The outline mixin ensures accessibility and visually consistent focus
// indicators for links, buttons, and other interactive components. It is
// especially useful for maintaining keyboard navigation visibility across
// modern browsers and custom UI design.
// -----------------------------------------------------------------------------
// NOTE: Use the outline mixin when styling interactive elements to preserve
// accessibility best practices while allowing for custom theme-aligned focus
// outlines.
//
// Available Params
// - $outline-width:    Defines the width of the outline
// - $outline-style:    Defines the style of the outline (default: solid)
// - $outline-color:    Defines the color of the outline
// - $outline-offset:   Defines the offset of the outline (optional)
// - $outline-radius:   Defines the border-radius of the outline (optional)
// -----------------------------------------------------------------------------
// Usage:
// @include mixin.outline(
//      $outline-width: 3px,
//      $outline-color: magenta,
//      $outline-offset: 3px,
//      $outline-radius: 8px
// );
// =============================================================================

@mixin outline(
    $outline-width,
    $outline-style: solid,
    $outline-color,
    $outline-offset: null,
    $outline-radius: null
) {
    outline: $outline-width $outline-style $outline-color;

    @if $outline-offset != null {
        outline-offset: $outline-offset;
    }

    @if $outline-radius != null {
        border-radius: $outline-radius;

        // Add focus and focus-within to fix issue with border radius not
        // displaying when element is focused
        &:focus,
        &:focus-within {
            border-radius: $outline-radius;
        }
    }
}

// =============================================================================
// Flex | v1.0.0
// -----------------------------------------------------------------------------
// Provides a shorthand flexbox utility mixin for the coastalskin theme
//
// The flex mixin provides a simple common flexbox pattern such as flex
// container setup, alignment, direction, gap and wrapping. These help reduce
// verbosity in component and layout styles while maintaining readability and
// consistency.
// -----------------------------------------------------------------------------
// NOTE: Use the flex mixin when building layouts or UI components that rely on
// the flexbox model behaviour. Designed to compliment grid-based layouts where
// flexible alignment and axis control is needed.
//
// Available Params:
// - $direction:    Flex Direction (row | column | etc)
// - $justify:      Main axis alignment (e.g. flex-start, center, space-between)
// - $align:        Cross axis alignment (e.g. stretch, center, baseline)
// - $wrap:         Wrapping behaviour (e.g. wrap | nowrap)
// - $gap:          Gap between child elements (e.g. 1rem, 10ch)
// -----------------------------------------------------------------------------
// Usage:
// @include mixin.flex($justify: center, $align: center, $gap: 1rem);
// =============================================================================

@mixin flex($direction: null, $justify: null, $wrap: null, $gap: null) {
    display: flex;

    @if $direction != null {
        flex-direction: $direction;
    }

    @if $justify != null {
        justify-content: $justify;
    }

    @if $align != null {
        align-items: $align;
    }

    @if $wrap != null {
        flex-wrap: $wrap;
    }

    @if $gap != null {
        gap: $gap;
    }
}

// =============================================================================
// Grid | v1.0.0
// -----------------------------------------------------------------------------
// Provides a shorthand grid utility mixin for the coastalskin theme.
//
// The grid mixin simplifies the setup of grid containers by abstracting common
// layout properties such as column/row definitions, gap control, alignment,
// and auto-flow direction. It supports both simple and complex grid structures
// while improving readability and reducing repetition.
// -----------------------------------------------------------------------------
// NOTE: Use the grid mixin when defining layout regions or UI sections that
// require two-dimension control. Ideal for responsive grids, card layouts, or
// content blocks that benefit from flexible spatial organisation.
//
// Available Params:
// - $cols      Defines column structure
// - $rows      Defines row structure
// - $gap       Space between rows (e.g. 0.25rem)
// - $justify   Justifies content along the inline axis
// - $align     Aligns content along the block axis
// - $flow      Controls grid auto-flow (e.g. row | column | dense | etc.)
// -----------------------------------------------------------------------------
// Usage:
// @include mixin.grid($cols: 2, $rows: 1, $gap: 1rem, $justify: space-between);
// =============================================================================

@mixin grid(
    $cols: null,
    $rows: null,
    $gap: null,
    $justify: null,
    $align: null,
    $flow: null
) {
    display: grid;

    @if $cols != null {
        grid-template-columns: repeat($cols, minmax(0, 1fr));
    }

    @if $rows != null {
        grid-template-rows: repeat($rows, minmax(0, 1fr));
    }

    @if $gap != null {
        gap: $gap;
    }

    @if $justify != null {
        justify-content: $justify;
    }

    @if $align != null {
        align-items: $align;
    }

    @if $flow != null {
        grid-auto-flow: $flow;
    }
}

// =============================================================================
// Position | v1.0.0
// -----------------------------------------------------------------------------
// Provides a shorthand position utility mixin for the coastalskin theme
//
// The position mixin simplifies setting common positioning patterns include
// absolute, relative, fixed, or sticky, with optional top, right, bottom, and
// left offsets. It enhances clarity, and reduces repetition when working with
// layout-level positioning across components.
// -----------------------------------------------------------------------------
// NOTE: Use the position mixin when you need to apply precise element
// placement without repeating verbose positioning properties. Ideal for
// overlays, badges, tooltips, etc. The $type param will check to ensure that a
// valid position type (absolute, relative, etc) is defined, if an invalid
// position type is added an error will be thrown.
//
// Available params:
// - $type      Position type (e.g. relative, absolute, fixed, sticky)
// - $top       Top offset (optional)
// - $right     Right offset (optional)
// - $bottom    Bottom offset (optional)
// - $left      Left offset (optional)
// - $block     Top and bottom offsets (optional)
// - $inline    Right and left offsets (optional)
// -----------------------------------------------------------------------------
// Usage:
// @include mixin.position($type: absolute, $top: 2rem, $left: 3rem);
// =============================================================================

@mixin position(
    $type,
    $top: null,
    $right: null,
    $bottom: null,
    $left: null,
    $block: null,
    $inline: null
) {
    // Define list of valid position type
    $valid-types: static, relative, absolute, sticky, fixed;

    // Check if passed $type is valid
    @if not list.index($valid-types, $type) {
        @error "Invalid position type '#{$type}'. Must be one of: #{list.join($valid-types, ', ')}.";
    }

    position: $type;

    @if $top != null {
        top: $top;
    }

    @if $right != null {
        right: $right;
    }

    @if $bottom != null {
        bottom: $bottom;
    }

    @if $left != null {
        left: $left;
    }

    @if $block != null {
        top: $top;
        bottom: $bottom;
    }

    @if $inline != null {
        right: $right;
        left: $left;
    }
}

// =============================================================================
// Size | v1.0.0
// -----------------------------------------------------------------------------
// Provides a shorthand utility mixin for setting element dimensions in the
// coastalskin theme.
//
// The size mixin allows you to quickly define width, height, max-width,
// min-width min-height and /or max-height properties on an element. It reduces
// repetitive declarations and promotes consistency across components where
// explicit sizing is required.
// -----------------------------------------------------------------------------
// NOTE: Use the size mixin when defining fixed or constrained dimensions for
// layout elements, images, buttons, cards, containers, etc. Supports partial
// use (e.g. only width or max-height).
//
// Available params
// - $width:        Sets the width (optional)
// - $height:       Sets the height (optional)
// - $max-width:    Sets the max-width (optional)
// - $min-width:    Sets the min-width (optional)
// - $max-height:   Sets the max-height (optional)
// - $min-height:   Sets the min-width (optional)
// -----------------------------------------------------------------------------
// Usage:
// @include mixin.size($width: 2.5rem, $height: auto);
// =============================================================================

@mixin size(
    $width: null,
    $height: null,
    $min-width: null,
    $min-height: null,
    $max-width: null,
    $max-height: null
) {
    @if $width != null {
        width: $width;
    }

    @if $height != null {
        height: $height;
    }

    @if $min-width != null {
        min-width: $min-width;
    }

    @if $min-height != null {
        min-height: $min-height;
    }

    @if $max-width != null {
        max-width: $max-width;
    }

    @if $max-height != null {
        max-height: $max-height;
    }
}

// =============================================================================
// Font Face | v1.0.0
// -----------------------------------------------------------------------------
// Provides a reusable mixin for defining @font-face rules in the coastalskin
// theme.
//
// The font face mixin simplifies the registration of custom fonts by wrapping
// the @font-face declaration in a configurable and reusable format. It
// supports specifying the font weight, family name, source URI, and font
// style, which defaults to normal.
// -----------------------------------------------------------------------------
// NOTE: Use this mixin to consistenly load custom fonts across the theme.
// Recommended for fonts served locally or from a CDN where you control the
// path.
//
// Available params:
// - $font-weight:  Font wight range of the font (400 700)
// - $font-family:  Name assigned to the font (used in font-family declarations)
// - $font-style:   Font style (e.g. normal, italics) (default: normal)
// - $font-uri:     Path to the font file (e.g. '../fonts/Font.woff2)
// -----------------------------------------------------------------------------
// Usage:
// @include mixin.font-face(
//     $font-weight: 400 700,
//     $font-family: 'Cadiz',
//     $font-uri: 'assets/fonts/cadiz/Cadiz.woff2'
// );
// =============================================================================

@mixin font-face($font-weight, $font-family, $font-style: normal, $font-uri) {
    @font-face {
        font-weight: $font-weight;
        font-family: $font-family;
        font-style: $font-style;
        font-display: swap;
        src: url(#{$font-uri});
    }
}

// =============================================================================
// Button | v1.0.0
// -----------------------------------------------------------------------------
// Provides a comprehensive button styling mixin for the coastal skin theme
//
// The `btn` mixin offers a flexible and configurable approach to styling
// buttons and interactive elements. It includes support for layout, spacing,
// color theming hover/focus-within states, border control, typography, and
// visual feedback through outline styling.
// -----------------------------------------------------------------------------
// NOTE: Use this mixin to construct base button or variant (e.g. primary,
// secondary, ghost, etc). Designed to pair with utility mixins such as
// `hover-focus-within, or icon alignment helpers.
//
// Interactive staes (:hover, :focus-within) are conditionally applied when
// relevant params are set, ensuring clean output with only required styles.
// =============================================================================

@mixin button(
    $width: fit-content,
    $gap: null,
    $padding: null,
    $font-weight: null,
    $font-size: null,
    $font-family: null,
    $tracking: null,
    $case: null,
    $radius: null,
    $border-width: null,
    $border-style: solid,
    $border-color: null,
    $border-color-hover: null,
    $bg: null,
    $bg-hover: null,
    $color: null,
    $color-hover: null,
    $outline-width: null,
    $outline-style: solid,
    $outline-color: null,
    $outline-offset: null,
    $transition: null
) {
    @if $padding != null {
        display: flex;
        width: $width;
        gap: $gap;
        padding: $padding;
    }

    @if $transition != null {
        transition: $transition;
    }

    @if $radius != null {
        border-radius: $radius;
    }

    @if $border-width != null or $border-color != null {
        border: $border-width solid $border-color;
    }

    @if $bg != null {
        background-color: $bg;
    }

    @if $color != null {
        color: $color;
    }

    @if $font-weight != null {
        font-weight: $font-weight;
    }

    @if $font-size != null {
        fonts-size: $font-size;
    }

    @if $font-family != null {
        font-family: $font-family;
    }

    @if $tracking != null {
        letter-spacing: $tracking;
    }

    @if $case != null {
        text-transform: $tracking;
    }

    @if $outline-color != null or $outline-offset != null {
        &:focus-within {
            @if $outline-color != null {
                outline-color: $outline-color;
            }

            @if $outline-offset != null {
                outline-offset: $outline-offset;
            }
        }
    }

    @if $radius !=
        null or
        $border-color-hover !=
        null or
        $bg-hover !=
        null or
        $color-hover !=
        null
    {
        &:hover,
        &:focus-within {
            @if $radius != null {
                border-radius: $radius;
            }

            @if $border-color-hover != null {
                border-color: $border-color-hover;
            }

            @if $bg-hover != null {
                background-color: $bg-hover;
            }

            @if $color-hover != null {
                color: $color-hover;
            }
        }
    }
}
